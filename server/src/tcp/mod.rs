// tcp/mod.rs

mod http; // the reason for the tcp folder: https://doc.rust-lang.org/rust-by-example/mod/split.html
const SITE_PATH: &str = "site/";

use std::io::{Read, Write};

// checks if a given 'untyped' vector is valid ASCII
pub fn is_vec_u8_ascii(bytes: Vec<u8>) -> bool {
	bytes.iter().all(|&byte| byte.is_ascii())
}

pub fn handle_tcp_stream(mut tcp_stream: std::net::TcpStream) {
    let tcp_stream_vec_u8: Vec<u8> = tcp_stream_to_vec_u8(&tcp_stream); // read request into typeless vector
    
    // TODO: We prob don't want to assert here. Handle this gracefully instead
    assert!(is_vec_u8_ascii(tcp_stream_vec_u8.clone()), "not valid US-ASCII"); // make sure the typeless vector is valid US-ASCII
    
    // the body of the request will always be empty with current implementation
    let http_request: http::HttpRequest = match http::vec_u8_to_http_request(tcp_stream_vec_u8) {
        Ok(http_request) => http_request,
        Err(e) => {
            let (status_code, reason_phrase) = match e {
                http::HttpRequestError::UnsupportedMethod => (b"501".to_vec(), b"Unsupported Method".to_vec()),
                http::HttpRequestError::BadRequest => (b"400".to_vec(), b"Bad Request".to_vec()),
                _ => (b"404".to_vec(), b"Not Found".to_vec()),
            };
            let http_response: http::HttpResponse = http::construct_http_response(status_code, reason_phrase);
            // TODO: Send the response
            println!("ERROR (HANDLE_TCP_STREAM): Invalid HTTP Request: {:?}", e);
            return; //TODO: Should this println? Should this return?
        }
    };

    let file_path: String = if http_request.start_line.request_target.eq(b"/") {
        String::from("index.html")
    } else {
        String::from_utf8(http_request.start_line.request_target).unwrap()
    };

    let (status_code, reason_phrase) = match std::fs::read(format!("{}{}", SITE_PATH, &file_path)) {
        Ok(_) => (200, "OK"),
        Err(_) => (404, "Not Found"),
    };

    // Load the requested page's contents into a "typeless" vector
    let file_contents: Vec<u8> = match std::fs::read(format!("{}{}", SITE_PATH, &file_path)) {
        Ok(v) => v,
        Err(_) => match std::fs::read(format!("{}{}", SITE_PATH, "404.html")) {
            // this error match was generated by Copilot
            Ok(v) => v,
            Err(e) => {
                println!("Failed to read 404.html: {}", e);
                Vec::new() // return an empty vector if both reads fail
            }
        },
    };

    // Pseudocode for needed logic:
    // now that we have the page or lackthereof that we want to send to them,
    // construct the http response with the appropriate status code
    // send the http response

    let http_response: String = format!(
        "HTTP/1.1 {} {}\r\nContent-Length: {}\r\n\r\n{}",
        status_code,
        reason_phrase,
        file_contents.len(),
        String::from_utf8_lossy(&file_contents)
    );

    // Write the HttpResponse to the TcpStream (i.e., connection)
    match tcp_stream.write(http_response.as_bytes()) {
        Ok(size) => match tcp_stream.local_addr() {
            Ok(local_addr) => println!("LOG (HANDLE_TCP_STREAM): TcpStream Write Success: {} (of size {} bytes) written to {}", file_path, size, local_addr),
            Err(e) => println!("WARNING (HANDLE_TCP_STREAM): Failed to log the local address: {}", e),
        },
        Err(e) => println!("ERROR (HANDLE_TCP_STREAM): TcpStream Write Error: {}", e),
    };
}

/// returns a "typeless" vector containing the contents of the given TcpStream (i.e., connection)
///
/// it's important to handle HTTP messages at the byte level and not interpret them
/// as Unicode without considering the specific encoding. In Rust, you can handle
/// HTTP messages at the byte level by reading them into a Vec<u8>.
///
/// # Arguments
///
/// * `tcp_stream` - The TcpStream to read the contents of
///
/// # Returns
///
/// A Vec<u8> of the TcpStream contents
///
/// # Examples
///
/// ```
/// let tcp_stream_vec_u8: Vec<u8> = tcp_stream_to_vec_u8(&tcp_stream);
/// ```
pub fn tcp_stream_to_vec_u8(mut tcp_stream: &std::net::TcpStream) -> Vec<u8> {
    let mut vec_buffer: Vec<u8> = Vec::new();

    // Set a read timeout for 5 seconds. This will help prevent the server from hanging if the client doesn't close the connection
    // SHOULD THIS LIVE HERE? OR SHOULD IT LIVE IN THE MAIN FUNCTION? OR EVEN UP ABOVE (IN HANDLETCPSTREAM)?
    // THE ASSUMPTION IS THAT THE THREAD POOL HAS THE CONNECTION NOW, SO WE WANT TO PREVENT INDIVIDUAL THREADS FROM HANGING
    match tcp_stream.set_read_timeout(Some(std::time::Duration::new(5, 0))) {
        Ok(_) => {}
        Err(e) => println!(
            "WARNING (TCP_STREAM_TO_VEC_U8): Failed to set read timeout: {}",
            e
        ),
    }

    // CHANGE THE BELOW TO BUFREADER

    // Read incoming data into a "typeless" vector
    let mut buffer: [u8; 1024] = [0; 1024]; // Adjust chunk size as needed
    match tcp_stream.read(&mut buffer) {
        Ok(0) => {} // Connection closed by the client
        Ok(bytes_read) => {
            println!(
                "LOG (TCP_STREAM_TO_VEC_U8): Read {} bytes from the TcpStream",
                bytes_read
            );
            vec_buffer.extend_from_slice(&buffer[..bytes_read]);
        }
        Err(e) => {
            // Shutdown the current TcpStream (i.e., connection)
            match tcp_stream.shutdown(std::net::Shutdown::Both) {
                Ok(_) => {}
                Err(e) => println!(
                    "ERROR (TCP_STREAM_TO_VEC_U8): TcpStream Shutdown Error: {}",
                    e
                ),
            };

            // Panic the current thread
            panic!(
                "ERROR (TCP_STREAM_TO_VEC_U8): Invalid HTTP Request. Shutting down the TcpStream. Error: {}",
                e
            );
        }
    }
    // println!(
    //     "Received {} bytes: {}",
    //     vec_buffer.len(),
    //     String::from_utf8_lossy(&vec_buffer)
    // );

    vec_buffer
}
